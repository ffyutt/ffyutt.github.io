<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="语冰"><meta name="copyright" content="语冰"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>ucosii学习2-临界区 | 语冰的小站</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_j5gk85dg4pf.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"ffyutt.github.io","root":"/","title":"ffyutt的小站","version":"1.5.3","mode":"time","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="临界区是什么？为什么定义了三种进入方式却只能在代码里找到第一种方式？我们会结合有关c语言的运行时栈的有关知识来探讨三种方法的可行性。">
<meta property="og:type" content="article">
<meta property="og:title" content="ucosii学习2-临界区">
<meta property="og:url" content="https://ffyutt.github.io/2021/04/ucosii/ucosii2.html">
<meta property="og:site_name" content="语冰的小站">
<meta property="og:description" content="临界区是什么？为什么定义了三种进入方式却只能在代码里找到第一种方式？我们会结合有关c语言的运行时栈的有关知识来探讨三种方法的可行性。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/fffyutt/image_warehouse/raw/master/img/image-20210402205722828.png">
<meta property="og:image" content="https://gitee.com/fffyutt/image_warehouse/raw/master/img/B66582D95F29B97F642C062B265BBBA1.jpg">
<meta property="og:image" content="https://gitee.com/fffyutt/image_warehouse/raw/master/img/B1E86FB2A066AEBC70B54DEA68C8536C.jpg">
<meta property="og:image" content="https://gitee.com/fffyutt/image_warehouse/raw/master/img/0D50CEDF1FC52CCE6C073A681965750D.jpg">
<meta property="article:published_time" content="2021-04-02T09:07:27.000Z">
<meta property="article:modified_time" content="2021-05-02T10:24:23.501Z">
<meta property="article:author" content="语冰">
<meta property="article:tag" content="stm32">
<meta property="article:tag" content="ucosii">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/fffyutt/image_warehouse/raw/master/img/image-20210402205722828.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="语冰"><img width="96" loading="lazy" src="/Yun.png" alt="语冰"></a><div class="site-author-name"><a href="/about/">语冰</a></div><span class="site-name">语冰的小站</span><sub class="site-subtitle">something fun</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">6</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">5</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">9</span></a></div><a class="site-state-item hty-icon-button" href="/null" title="设置"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/ffyutt" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="cxy1276018778@163.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.now.sh/" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-send-plane-2-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text"> 内容简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-number">2.</span> <span class="toc-text"> 正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">2.1.</span> <span class="toc-text"> 什么是临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text"> 进入临界区的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#method1-%E7%9B%B4%E6%8E%A5%E5%85%B3%E4%B8%AD%E6%96%AD"><span class="toc-number">2.2.1.</span> <span class="toc-text"> method1 直接关中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#method2-%E9%80%9A%E8%BF%87%E5%A0%86%E6%A0%88%E4%BF%9D%E5%AD%98%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AD%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text"> method2 通过堆栈保存程序状态字寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#method3"><span class="toc-number">2.2.3.</span> <span class="toc-text"> method3</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://ffyutt.github.io/2021/04/ucosii/ucosii2.html"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="语冰"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="语冰的小站"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">ucosii学习2-临界区</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-04-02 17:07:27" itemprop="dateCreated datePublished" datetime="2021-04-02T17:07:27+08:00">2021-04-02</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-05-02 18:24:23" itemprop="dateModified" datetime="2021-05-02T18:24:23+08:00">2021-05-02</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/ucosii/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">ucosii</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/stm32/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">stm32</span></a><a class="tag-item" href="/tags/ucosii/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">ucosii</span></a><a class="tag-item" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">学习笔记</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="内容简介"><a class="markdownIt-Anchor" href="#内容简介"></a> 内容简介</h2>
<p>​	临界区是什么？为什么定义了三种进入方式却只能在代码里找到第一种方式？</p>
<p>​	我们会结合有关c语言的运行时栈的有关知识来探讨三种方法的可行性。</p>
<h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2>
<p>​	在第一次建立能够骗过编译器的空ucosii工程中，我们在os_cpu.h中定义了两个函数，简单看下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OS_CRITICAL_METHOD = 1 :直接使用处理器的开关中断指令来实现宏 </span></span><br><span class="line"><span class="comment">//OS_CRITICAL_METHOD = 2 :利用堆栈保存和恢复CPU的状态 </span></span><br><span class="line"><span class="comment">//OS_CRITICAL_METHOD = 3 :利用编译器扩展功能获得程序状态字，保存在局部变量cpu_sr</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  OS_CRITICAL_METHOD   3	 	<span class="comment">//进入临界段的方法</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  OS_ENTER_CRITICAL()  &#123;cpu_sr = OS_CPU_SR_Save();&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  OS_EXIT_CRITICAL()   &#123;OS_CPU_SR_Restore(cpu_sr);&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function">OS_CPU_SR  <span class="title">OS_CPU_SR_Save</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>       <span class="title">OS_CPU_SR_Restore</span><span class="params">(OS_CPU_SR cpu_sr)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>​	其实，在很多的实时操作系统中，我们都只能找到第三种，前两种方法或多或少都有着问题，我们会介绍这三种方法的实现，探讨其问题与优势，当然，我对gcc编译器的理解，对c语言栈的理解可能不是很到位，难免会有疏漏，欢迎指正。</p>
<h3 id="什么是临界区"><a class="markdownIt-Anchor" href="#什么是临界区"></a> 什么是临界区</h3>
<p>​	<strong>临界区</strong>指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。与普通的c语言写的单个程序不同，在一个操作系统中，存在这大量的只能够被互斥访问的资源。我们可以在信号量经典的生产者消费者的问题中发现，如果不能保证一些资源的互斥访问，有些设备的运行会出现问题（比如打印机在打印时只能同时被一个”人“访问），甚至整个系统的运行都会陷入不确定性，这是不可接受的。</p>
<h3 id="进入临界区的方法"><a class="markdownIt-Anchor" href="#进入临界区的方法"></a> 进入临界区的方法</h3>
<p>​	进入临界区的方法有很多，比如关中断，禁止调度等等。我们今天要将的ucosii中的进入临界区的三个方案，都是基于关中断的。</p>
<p>​	PS，关中断是一种与硬件强相关的方法，我们这里结合STM32F401RE进行讲解。</p>
<h4 id="method1-直接关中断"><a class="markdownIt-Anchor" href="#method1-直接关中断"></a> method1 直接关中断</h4>
<p>​	定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_ENTER_CRITICALL() (Cli())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_EXIT_CRITICAL() (Sti())</span></span><br></pre></td></tr></table></figure>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Cli</span></span><br><span class="line">	<span class="keyword">CPSID</span>   I <span class="comment">;PRIMASK=1,该位是中断总开关</span></span><br><span class="line">	<span class="keyword">BX</span> <span class="built_in">LR</span> <span class="comment">;函数返回</span></span><br><span class="line"><span class="symbol">Sti</span></span><br><span class="line">	<span class="keyword">CPSIE</span>	I <span class="comment">;PRIMASK=0,关中断</span></span><br><span class="line">	<span class="keyword">BX</span> <span class="built_in">LR</span> </span><br></pre></td></tr></table></figure>
<p>​	需要注意的是，在STM32F401RE中是不存在FIQ的，所以CPSID I将IRQ中断关闭就是将所有的中断都关闭了，包括systick等一系列中断都不会响应。systick是系统的心跳，从理论上来讲是不可以被关闭的，但是实际上，我们在临界区内所做的事情往往只有几行汇编，执行这些代码的时间和系统的心跳时间之间差了好几个数量级，几乎可以忽略不记，所以在这里这种简单粗暴的关中断是可行的。听说还有别的可以不屏蔽systick的问题，但是这相关的问题就更多了，按下不表。</p>
<p>​	这种方法是存在很大问题的，他不支持访问临界区的嵌套，因为他无法区分你是进的临界区是哪一级的临界区，只要离开一次临界区，本来关闭的中断就会打开，外层的临界区就失效了，可以参考下图。</p>
<img src="https://gitee.com/fffyutt/image_warehouse/raw/master/img/image-20210402205722828.png" alt="直接关中断进入临界区的问题" style="zoom: 33%;" / loading="lazy">
<h4 id="method2-通过堆栈保存程序状态字寄存器"><a class="markdownIt-Anchor" href="#method2-通过堆栈保存程序状态字寄存器"></a> method2 通过堆栈保存程序状态字寄存器</h4>
<p>​	demo如下</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define OS_ENTER_CRITICAL() (PushAndCli())</span></span><br><span class="line"><span class="comment">#define OS_EXIT_CRITICAL() (Pop())</span></span><br></pre></td></tr></table></figure>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">PushAndCli</span></span><br><span class="line">    PUSHF</span><br><span class="line">    <span class="keyword">CPSID</span>   I				</span><br><span class="line">    <span class="keyword">BX</span>      <span class="built_in">LR</span>			    </span><br><span class="line"></span><br><span class="line"><span class="symbol">Pop</span></span><br><span class="line">    POPF</span><br><span class="line">    <span class="keyword">BX</span>      <span class="built_in">LR</span>		</span><br></pre></td></tr></table></figure>
<p>​	看起来是不是很完美，我走之前先把之前的状态存到堆栈里去，走之后又从堆栈中取出来，这样就可以记录下来每一次进出临界区时候的状态，不管堆叠几次都不会出问题。</p>
<p>​	实际上，一般在使用这种方式的时候是不会出问题的，我们可以先来看看函数堆栈在函数运行时的变化。</p>
<p>​	当一个函数被调用时，编译器会自动为这个函数分配一个栈，我们可以在《c和指针》的第18章找到x86构架下的一种实现。</p>
<p>​	我们首先要对bp sp等寄存器有一些了解（建议百度），我们这里假设只有a1使用寄存器传值，其他的参数使用堆栈传值（在实际情况里面，在参数较少时会优先使用寄存器传值，只有当寄存器不足时才会使用堆栈传值）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> a0, <span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = a1 + a2 + a3 + a4;						<span class="comment">//(2)	</span></span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	add(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);									<span class="comment">//(1)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	在进入执行子函数的代码之前（1），编译器会在主函数中把add的第一个参数存到r0中，其他四个参数逆序压入堆栈中（逆序的原因是因为子函数不知道究竟会传给他几个参数，如果逆序传入的话，距离自己bp指针最近的那个就是第一个参数，一路找下去就行），接下来会执行跳转到子函数的指令，这条指令同时将返回地址压入堆栈中。现在的堆栈情况如图所示，上方是低地址</p>
<img src="https://gitee.com/fffyutt/image_warehouse/raw/master/img/B66582D95F29B97F642C062B265BBBA1.jpg" alt="主函数结束时堆栈" style="zoom: 33%;" / loading="lazy">
<p>​	同时进入子函数（2），在子函数的开始我们将旧的bp指针的内容入栈，同时让bp指针指向当前sp指针的位置，当前sp指针的内容是旧bp指针在栈中存在的位置，将这里作为子函数的栈底，同时将我们之前存在寄存器里的值和函数的局部变量一起丢进子函数的堆栈中，他们的顺序如图所示</p>
<img src="https://gitee.com/fffyutt/image_warehouse/raw/master/img/B1E86FB2A066AEBC70B54DEA68C8536C.jpg" alt="子函数指行时的函数栈" style="zoom:50%;" / loading="lazy">
<p>​	现在我们有了一个堆栈，从高地址到低地址分别存了反序压入的参数，旧的bp（旧堆栈帧指针），局部变量和被保存的寄存器的值，bp的上面的子函数的堆栈，bp的下面是主函数的堆栈。当我们希望找一个传入参数时，就让bp指针向高地址寻找，当我们希望找一个局部变量时，就让bp指针向低地址寻找，完美。</p>
<p>​	好了现在子函数结束，准备返回，子函数会把保存的寄存器的值返还给寄存器，让bp指针指向主函数的bp指针，然后返回地址出栈给pc，此时sp指针指向的是返回地址。我们需要注意的是此时传入的参数还没有被清楚，因为只有主函数才知道到底传入了几个参数，只有由主函数清楚这些数据才是安全的。</p>
<p>​	现在我们讲完了在x86构架下的函数栈的知识，然后我发现在STM32F4平台上的实现和上面有些出入，他并没有栈底指针bp，而是通过sp指针进行相对寻址，我们可以结合由MDK生成的STM32F4的一段汇编来讲解，源代码和汇编代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mypush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mypop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5, <span class="keyword">int</span> a6, <span class="keyword">int</span> a7)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">8</span>, x2 = <span class="number">9</span>, x3 = <span class="number">10</span>, x4 = <span class="number">11</span>, x5 = <span class="number">12</span>, x6 = <span class="number">13</span>, x7 = <span class="number">14</span>;</span><br><span class="line">	mypush();</span><br><span class="line">    <span class="comment">//这里加这么多变量只是为了把寄存器用完,逼他去栈里面把数据取出来,从而暴露问题</span></span><br><span class="line">	x = a + a2 + a3 + a4 + a5 + a6 + a7 + x + x2 + x4 + x5 + x6 + x7 + x3;</span><br><span class="line">	mypop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    add1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">		<span class="meta">EXPORT</span> mypush</span><br><span class="line">		<span class="meta">EXPORT</span> mypop</span><br><span class="line"></span><br><span class="line">		<span class="meta">PRESERVE8</span> </span><br><span class="line">		</span><br><span class="line">		<span class="meta">AREA</span>    <span class="title">|.text|</span>, <span class="meta">CODE</span>, <span class="meta">READONLY</span></span><br><span class="line">        <span class="meta">THUMB</span> </span><br><span class="line"></span><br><span class="line"><span class="symbol">mypush</span></span><br><span class="line">	<span class="keyword">PUSH</span> &#123;<span class="built_in">r0</span>&#125;</span><br><span class="line">	<span class="keyword">BX</span> <span class="built_in">LR</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">mypop</span></span><br><span class="line">	<span class="keyword">POP</span> &#123;<span class="built_in">r0</span>&#125;</span><br><span class="line">	<span class="keyword">BX</span> <span class="built_in">LR</span></span><br><span class="line">	<span class="meta">end</span></span><br></pre></td></tr></table></figure>
<p>​	我们可以跟着汇编走一走流程，这里会把汇编与对应的c语言都对应起来注释也加的比较全我觉得是可以看懂的</p>
<p>​	main函数</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">12</span>: int main()&#123; </span><br><span class="line"><span class="number">0x080004B0</span> B50E      <span class="keyword">PUSH</span>          &#123;<span class="built_in">r1</span>-<span class="built_in">r3</span>,<span class="built_in">lr</span>&#125;		<span class="comment">;主函数也是一个函数,bsp在调用主函数时也要保存上文  ;sp_a</span></span><br><span class="line">    <span class="number">13</span>:     add1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)<span class="comment">; </span></span><br><span class="line"><span class="number">0x080004B2</span> <span class="number">2007</span>      <span class="keyword">MOVS</span>          <span class="built_in">r0</span>,<span class="number">#0x07</span></span><br><span class="line"><span class="number">0x080004B4</span> <span class="number">2106</span>      <span class="keyword">MOVS</span>          <span class="built_in">r1</span>,<span class="number">#0x06</span></span><br><span class="line"><span class="number">0x080004B6</span> <span class="number">2205</span>      <span class="keyword">MOVS</span>          <span class="built_in">r2</span>,<span class="number">#0x05</span></span><br><span class="line"><span class="number">0x080004B8</span> <span class="number">2304</span>      <span class="keyword">MOVS</span>          <span class="built_in">r3</span>,<span class="number">#0x04</span>			<span class="comment">;前面四行在将add1的参数传给寄存器</span></span><br><span class="line"><span class="number">0x080004BA</span> E9CD2100  <span class="keyword">STRD</span>          <span class="built_in">r2</span>,<span class="built_in">r1</span>,[<span class="built_in">sp</span>,<span class="number">#0</span>]	<span class="comment">;这里将r1和r2寄存器的值存到sp对应的位置,也就是r1r2入栈</span></span><br><span class="line"><span class="number">0x080004BE</span> <span class="number">9002</span>      <span class="keyword">STR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x08</span>]	<span class="comment">;r0入栈									;sp_b</span></span><br><span class="line">													<span class="comment">;这里发现了奇怪的事情,往栈里存东西把第一行push的信息覆盖了</span></span><br><span class="line">													<span class="comment">;是不是忘记给主函数开辟栈空间了,但是代码就是这样,等一手dl解惑</span></span><br><span class="line"><span class="number">0x080004C0</span> <span class="number">2203</span>      <span class="keyword">MOVS</span>          <span class="built_in">r2</span>,<span class="number">#0x03</span></span><br><span class="line"><span class="number">0x080004C2</span> <span class="number">2102</span>      <span class="keyword">MOVS</span>          <span class="built_in">r1</span>,<span class="number">#0x02</span></span><br><span class="line"><span class="number">0x080004C4</span> <span class="number">2001</span>      <span class="keyword">MOVS</span>          <span class="built_in">r0</span>,<span class="number">#0x01</span>			<span class="comment">;继续存入add1的参数到寄存器</span></span><br><span class="line"><span class="number">0x080004C6</span> F7FFFFBD  BL.W          add1 (<span class="number">0x08000444</span>)<span class="comment">;调用函数add1									;(1)</span></span><br><span class="line">    <span class="number">14</span>:     return <span class="number">0</span><span class="comment">; </span></span><br><span class="line"><span class="number">0x080004CA</span> <span class="number">2000</span>      <span class="keyword">MOVS</span>          <span class="built_in">r0</span>,<span class="number">#0x00</span>			<span class="comment">;把0赋值给r0,这个0就是return后面的0</span></span><br><span class="line">    <span class="number">15</span>: &#125; </span><br><span class="line"><span class="number">0x080004CC</span> BD0E      <span class="keyword">POP</span>           &#123;<span class="built_in">r1</span>-<span class="built_in">r3</span>,<span class="built_in">pc</span>&#125;		<span class="comment">;开始保存上文了现在恢复上文</span></span><br><span class="line"><span class="number">0x080004CE</span> F04F7040  <span class="keyword">MOV</span>           <span class="built_in">r0</span>,<span class="number">#0x3000000</span></span><br><span class="line"><span class="number">0x080004D2</span> EEE10A10  VMSR           FPSCR, <span class="built_in">r0</span></span><br><span class="line"><span class="number">0x080004D6</span> <span class="number">4770</span>      <span class="keyword">BX</span>            <span class="built_in">lr</span></span><br></pre></td></tr></table></figure>
<p>​	add1函数</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span>: int add1(int a, int <span class="built_in">a2</span>, int <span class="built_in">a3</span>, int <span class="built_in">a4</span>, int a5, int a6, int a7)&#123; </span><br><span class="line"><span class="number">0x08000444</span> E92D4FF0  <span class="keyword">PUSH</span>          &#123;<span class="built_in">r4</span>-<span class="built_in">r11</span>,<span class="built_in">lr</span>&#125;			<span class="comment">;函数开始 保存之前的寄存器值,方便自己用这些寄存器	;sp_c</span></span><br><span class="line"><span class="number">0x08000448</span> B087      <span class="keyword">SUB</span>           <span class="built_in">sp</span>,<span class="built_in">sp</span>,<span class="number">#0x1C</span>			<span class="comment">;为子函数开辟堆栈,arm应该是有办法计算出到底需要多少的栈的</span></span><br><span class="line">														<span class="comment">;这里开辟的栈是刚刚好的,你调整参数个数发现不是巧合</span></span><br><span class="line">														<span class="comment">;sp_d</span></span><br><span class="line"><span class="number">0x0800044A</span> <span class="number">4604</span>      <span class="keyword">MOV</span>           <span class="built_in">r4</span>,<span class="built_in">r0</span></span><br><span class="line"><span class="number">0x0800044C</span> <span class="number">460</span>D      <span class="keyword">MOV</span>           <span class="built_in">r5</span>,<span class="built_in">r1</span></span><br><span class="line"><span class="number">0x0800044E</span> <span class="number">4616</span>      <span class="keyword">MOV</span>           <span class="built_in">r6</span>,<span class="built_in">r2</span></span><br><span class="line"><span class="number">0x08000450</span> <span class="number">461</span>F      <span class="keyword">MOV</span>           <span class="built_in">r7</span>,<span class="built_in">r3</span>				<span class="comment">;之前保存在r0-r3寄存器的参数传入自己的寄存器</span></span><br><span class="line"><span class="number">0x08000452</span> E9DD9A11  <span class="keyword">LDRD</span>          <span class="built_in">r9</span>,<span class="built_in">r10</span>,[<span class="built_in">sp</span>,<span class="number">#0x44</span>]	<span class="comment">;从栈里面取出之前传入的参数4和5</span></span><br><span class="line"><span class="number">0x08000456</span> F8DD8040  <span class="keyword">LDR</span>           <span class="built_in">r8</span>,[<span class="built_in">sp</span>,<span class="number">#0x40</span>]		<span class="comment">;从栈里面取出之前传入的参数6</span></span><br><span class="line">     <span class="number">5</span>:                 int x = <span class="number">8</span>, x2 = <span class="number">9</span>, x3 = <span class="number">10</span>, x4 = <span class="number">11</span>, x5 = <span class="number">12</span>, x6 = <span class="number">13</span>, x7 = <span class="number">14</span><span class="comment">; </span></span><br><span class="line"><span class="number">0x0800045A</span> F04F<span class="number">0B0</span>8  <span class="keyword">MOV</span>           <span class="built_in">r11</span>,<span class="number">#0x08</span>			<span class="comment">;保存在子函数中定义的局部变量</span></span><br><span class="line"><span class="number">0x0800045E</span> <span class="number">2009</span>      <span class="keyword">MOVS</span>          <span class="built_in">r0</span>,<span class="number">#0x09</span></span><br><span class="line"><span class="number">0x08000460</span> <span class="number">9006</span>      <span class="keyword">STR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x18</span>]		<span class="comment">;寄存器存不下局部变量了,把局部变量往栈里放			;(2)</span></span><br><span class="line"><span class="number">0x08000462</span> <span class="number">200</span>A      <span class="keyword">MOVS</span>          <span class="built_in">r0</span>,<span class="number">#0x0A</span></span><br><span class="line"><span class="number">0x08000464</span> <span class="number">9005</span>      <span class="keyword">STR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x14</span>]</span><br><span class="line"><span class="number">0x08000466</span> <span class="number">200</span>B      <span class="keyword">MOVS</span>          <span class="built_in">r0</span>,<span class="number">#0x0B</span></span><br><span class="line"><span class="number">0x08000468</span> <span class="number">9004</span>      <span class="keyword">STR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x10</span>]</span><br><span class="line"><span class="number">0x0800046A</span> <span class="number">200</span>C      <span class="keyword">MOVS</span>          <span class="built_in">r0</span>,<span class="number">#0x0C</span></span><br><span class="line"><span class="number">0x0800046C</span> <span class="number">9003</span>      <span class="keyword">STR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x0C</span>]</span><br><span class="line"><span class="number">0x0800046E</span> <span class="number">200</span>D      <span class="keyword">MOVS</span>          <span class="built_in">r0</span>,<span class="number">#0x0D</span></span><br><span class="line"><span class="number">0x08000470</span> <span class="number">9002</span>      <span class="keyword">STR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x08</span>]</span><br><span class="line"><span class="number">0x08000472</span> <span class="number">200</span>E      <span class="keyword">MOVS</span>          <span class="built_in">r0</span>,<span class="number">#0x0E</span></span><br><span class="line"><span class="number">0x08000474</span> <span class="number">9001</span>      <span class="keyword">STR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x04</span>]		<span class="comment">;终于把存不下的数据存入栈里了						;(3)</span></span><br><span class="line">     <span class="number">6</span>:                 mypush()<span class="comment">; </span></span><br><span class="line">     <span class="number">7</span>:     <span class="comment">//这里加这么多变量只是为了把寄存器用完,逼他去栈里面把数据取出来,从而暴露问题</span></span><br><span class="line"><span class="number">0x08000476</span> F7FFFEEF  BL.W          mypush (<span class="number">0x08000258</span>)	<span class="comment">;调用函数,这个函数没有参数</span></span><br><span class="line">     <span class="number">8</span>:                 x = a + <span class="built_in">a2</span> + <span class="built_in">a3</span> + <span class="built_in">a4</span> + a5 + a6 + a7 + x + x2 + x4 + x5 + x6 + x7 + x3<span class="comment">; </span></span><br><span class="line"><span class="number">0x0800047A</span> <span class="number">1960</span>      <span class="keyword">ADDS</span>          <span class="built_in">r0</span>,<span class="built_in">r4</span>,<span class="built_in">r5</span>				<span class="comment">;开始做加法,不断将存在寄存器里的数加起来</span></span><br><span class="line"><span class="number">0x0800047C</span> <span class="number">4430</span>      <span class="keyword">ADD</span>           <span class="built_in">r0</span>,<span class="built_in">r0</span>,<span class="built_in">r6</span></span><br><span class="line"><span class="number">0x0800047E</span> <span class="number">4438</span>      <span class="keyword">ADD</span>           <span class="built_in">r0</span>,<span class="built_in">r0</span>,<span class="built_in">r7</span></span><br><span class="line"><span class="number">0x08000480</span> <span class="number">4440</span>      <span class="keyword">ADD</span>           <span class="built_in">r0</span>,<span class="built_in">r0</span>,<span class="built_in">r8</span></span><br><span class="line"><span class="number">0x08000482</span> <span class="number">4448</span>      <span class="keyword">ADD</span>           <span class="built_in">r0</span>,<span class="built_in">r0</span>,<span class="built_in">r9</span></span><br><span class="line"><span class="number">0x08000484</span> <span class="number">4450</span>      <span class="keyword">ADD</span>           <span class="built_in">r0</span>,<span class="built_in">r0</span>,<span class="built_in">r10</span></span><br><span class="line"><span class="number">0x08000486</span> EB00010B  <span class="keyword">ADD</span>           <span class="built_in">r1</span>,<span class="built_in">r0</span>,<span class="built_in">r11</span></span><br><span class="line"><span class="number">0x0800048A</span> <span class="number">9806</span>      <span class="keyword">LDR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x18</span>]		<span class="comment">;有部分数据存在栈中,从栈中取出来加起来			;(4)</span></span><br><span class="line"><span class="number">0x0800048C</span> <span class="number">4401</span>      <span class="keyword">ADD</span>           <span class="built_in">r1</span>,<span class="built_in">r1</span>,<span class="built_in">r0</span></span><br><span class="line"><span class="number">0x0800048E</span> <span class="number">9804</span>      <span class="keyword">LDR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x10</span>]</span><br><span class="line"><span class="number">0x08000490</span> <span class="number">4401</span>      <span class="keyword">ADD</span>           <span class="built_in">r1</span>,<span class="built_in">r1</span>,<span class="built_in">r0</span></span><br><span class="line"><span class="number">0x08000492</span> <span class="number">9803</span>      <span class="keyword">LDR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x0C</span>]</span><br><span class="line"><span class="number">0x08000494</span> <span class="number">4401</span>      <span class="keyword">ADD</span>           <span class="built_in">r1</span>,<span class="built_in">r1</span>,<span class="built_in">r0</span></span><br><span class="line"><span class="number">0x08000496</span> <span class="number">9802</span>      <span class="keyword">LDR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x08</span>]</span><br><span class="line"><span class="number">0x08000498</span> <span class="number">4401</span>      <span class="keyword">ADD</span>           <span class="built_in">r1</span>,<span class="built_in">r1</span>,<span class="built_in">r0</span></span><br><span class="line"><span class="number">0x0800049A</span> <span class="number">9801</span>      <span class="keyword">LDR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x04</span>]</span><br><span class="line"><span class="number">0x0800049C</span> <span class="number">4401</span>      <span class="keyword">ADD</span>           <span class="built_in">r1</span>,<span class="built_in">r1</span>,<span class="built_in">r0</span></span><br><span class="line"><span class="number">0x0800049E</span> <span class="number">9805</span>      <span class="keyword">LDR</span>           <span class="built_in">r0</span>,[<span class="built_in">sp</span>,<span class="number">#0x14</span>]</span><br><span class="line"><span class="number">0x080004A0</span> EB01<span class="number">0B00</span>  <span class="keyword">ADD</span>           <span class="built_in">r11</span>,<span class="built_in">r1</span>,<span class="built_in">r0</span>			<span class="comment">;加完了									;(5)</span></span><br><span class="line">     <span class="number">9</span>:                 mypop()<span class="comment">; </span></span><br><span class="line"><span class="number">0x080004A4</span> F7FFFEDA  BL.W          mypop (<span class="number">0x0800025C</span>)	<span class="comment">;调用mypop函数</span></span><br><span class="line">    <span class="number">10</span>:     return <span class="number">0</span><span class="comment">; </span></span><br><span class="line"><span class="number">0x080004A8</span> <span class="number">2000</span>      <span class="keyword">MOVS</span>          <span class="built_in">r0</span>,<span class="number">#0x00</span>				<span class="comment">;返回值0存入r0</span></span><br><span class="line">    <span class="number">11</span>: &#125; </span><br><span class="line"><span class="number">0x080004AA</span> B007      <span class="keyword">ADD</span>           <span class="built_in">sp</span>,<span class="built_in">sp</span>,<span class="number">#0x1C</span>			<span class="comment">;销毁子函数的栈</span></span><br><span class="line"><span class="number">0x080004AC</span> E8BD8FF0  <span class="keyword">POP</span>           &#123;<span class="built_in">r4</span>-<span class="built_in">r11</span>,<span class="built_in">pc</span>&#125;			<span class="comment">;返回调用子函数时的现场,同时pc回到主函数,继续执行</span></span><br></pre></td></tr></table></figure>
<p>push和pop函数</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">9</span>: mypush</span><br><span class="line">    <span class="number">10</span>:         <span class="keyword">PUSH</span> &#123;<span class="built_in">r0</span>&#125; </span><br><span class="line"><span class="number">0x08000258</span> B401      <span class="keyword">PUSH</span>          &#123;<span class="built_in">r0</span>&#125;					<span class="comment">;将r0压栈,这里模拟的是第二种进入临界区的办法,往栈中压了一个值</span></span><br><span class="line">														<span class="comment">;sp_E</span></span><br><span class="line">    <span class="number">13</span>:         <span class="keyword">BX</span> <span class="built_in">LR</span> 									<span class="comment">;等于return,函数返回</span></span><br><span class="line"><span class="number">0x0800025A</span> <span class="number">4770</span>      <span class="keyword">BX</span>            <span class="built_in">lr</span></span><br><span class="line"></span><br><span class="line">    <span class="number">15</span>: mypop </span><br><span class="line">    <span class="number">16</span>:         <span class="keyword">POP</span> &#123;<span class="built_in">r0</span>&#125; 								</span><br><span class="line"><span class="number">0x0800025C</span> BC01      <span class="keyword">POP</span>           &#123;<span class="built_in">r0</span>&#125;					<span class="comment">;栈顶数据出栈到r0寄存器</span></span><br><span class="line">    <span class="number">17</span>:         <span class="keyword">BX</span> <span class="built_in">LR</span> </span><br><span class="line"><span class="number">0x0800025E</span> <span class="number">4770</span>      <span class="keyword">BX</span>            <span class="built_in">lr</span>					<span class="comment">;函数返回</span></span><br></pre></td></tr></table></figure>
<p>​	大致浏览上面的汇编，我们至少能够明白，在没有bp指针的这段代码中，存在栈中的数据是通过栈顶指针sp进行相对定位的，仔细观察(2)-(3)和(4)-(5)的代码，我们不难发现他们使用的相对于sp的相对地址都是一样的，也就是说，不管我们在中间怎么操作sp指针，我们的函数始终认为以下均为4字节的起始地址。</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">sp</span>-<span class="number">0x04</span>] = <span class="number">0xE</span></span><br><span class="line">[<span class="built_in">sp</span>-<span class="number">0x08</span>] = <span class="number">0xD</span></span><br><span class="line">[<span class="built_in">sp</span>-<span class="number">0x0C</span>] = <span class="number">0xC</span>  	 <span class="comment">;函数以为的数据</span></span><br></pre></td></tr></table></figure>
<p>​	但是很遗憾的是，我们在将数据存入堆栈和将数据取出堆栈之间进行了push操作，push操作的副作用是sp–，也就是说，如果说我们在存数据的时候的sp我们称为sp0的话，我们在取数据的时候的sp已经不是sp0了，变成sp0–了，所以所有的数据都错位了一格，即</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">sp</span>-<span class="number">0x04</span>] = ?</span><br><span class="line">[<span class="built_in">sp</span>-<span class="number">0x08</span>] = <span class="number">0xE</span></span><br><span class="line">[<span class="built_in">sp</span>-<span class="number">0x0C</span>] = <span class="number">0xD</span>		<span class="comment">;实际上的数据</span></span><br></pre></td></tr></table></figure>
<p>​	最后我们也得不到正确的0x69，在我这里我发现最后存入r11的是0x60，反正，结果已经变的不可预知了。</p>
<p>​	下面简单画下整个栈的情况，下图中我使用sp_a sp_b sp_c来表示sp的第一次变动第二次变动</p>
<img src="https://gitee.com/fffyutt/image_warehouse/raw/master/img/0D50CEDF1FC52CCE6C073A681965750D.jpg" alt="STM32F401RE下栈的情况" style="zoom: 50%;" / loading="lazy">
<p>​	当然,你说如果我们在汇编代码里先给mypush分配栈空间，也就是先让sp–，然后在函数返回的时候再sp++，销毁栈，这样add1函数内的局部变量访问就不会出问题了，但是，这样做还有一个更大的逻辑问题，当栈指针sp++，意义是mypush的栈被销毁，那么在这个栈空间中的数据都失去了意义，哪怕你马上进入mypop确实会返回正确的存入的值，但是我们只需要在mypush和mypop之间进行一次使用了栈空间的函数调用，直接会把在不受保护空间内的状态信息覆盖，我们就失去了这个信息，哪怕是在有bp指针的x86下也会出现这个问题（以上一段叙述没有实践过，纯理论）</p>
<p>​	此外，在查资料的过程中我还发现了一个编译选项 -fno-defer-pop，官方的解释如下：For machines that must pop arguments after a function call, always pop the arguments as soon as each function returns. At levels -O1 and higher, -fdefer-pop is the default; this allows the compiler to let arguments accumulate on the stack for several function calls and pop them all at once. 个人觉得这种策略可能也会影响第二种方案的安全性，但是我不想想了。</p>
<h4 id="method3"><a class="markdownIt-Anchor" href="#method3"></a> method3</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  OS_CRITICAL_METHOD   3	 	<span class="comment">//进入临界段的方法</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  OS_ENTER_CRITICAL()  &#123;cpu_sr = OS_CPU_SR_Save();&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  OS_EXIT_CRITICAL()   &#123;OS_CPU_SR_Restore(cpu_sr);&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function">OS_CPU_SR  <span class="title">OS_CPU_SR_Save</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>       <span class="title">OS_CPU_SR_Restore</span><span class="params">(OS_CPU_SR cpu_sr)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">OS_CPU_SR_Save</span></span><br><span class="line">    <span class="keyword">MRS</span>     <span class="built_in">R0</span>, PRIMASK  	<span class="comment">;R0是默认的返回参数存放的位置，可以理解为在函数结束时return R0</span></span><br><span class="line">    <span class="keyword">CPSID</span>   I				</span><br><span class="line">    <span class="keyword">BX</span>      <span class="built_in">LR</span>			    </span><br><span class="line"></span><br><span class="line"><span class="symbol">OS_CPU_SR_Restore</span></span><br><span class="line">    <span class="keyword">MSR</span>     PRIMASK, <span class="built_in">R0</span>	   	<span class="comment">;同理，R0也是默认的传入的第一个参数，也就是这个函数唯一的参数cpu_sr</span></span><br><span class="line">    <span class="keyword">BX</span>      <span class="built_in">LR</span>				</span><br></pre></td></tr></table></figure>
<p>​	其实第二种方法和第三种的唯一区别就是，第二种是要用了才想起来要给PRIMASK一个空间存放他，第三种是一开始就给你准备好了空间（在栈里或者寄存器里由编译器给你留了一个空间cpu_sr）等着你去放，这样明显更加安全，实际上ucosii最后所采用的也是第三种方式。</p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>语冰</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://ffyutt.github.io/2021/04/ucosii/ucosii2.html" title="ucosii学习2-临界区">https://ffyutt.github.io/2021/04/ucosii/ucosii2.html</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/04/%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8/%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97.html" rel="prev" title="姿态解算"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">姿态解算</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/04/%E5%89%8D%E7%AB%AF/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" rel="next" title="js学习笔记"><span class="post-nav-text">js学习笔记</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 语冰</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.5.3</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>